<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>圈圈叉叉 - Tic Tac Toe</title>
  <style>
    :root{--bg:#f7f7fb;--card:#ffffff;--accent:#2b6cb0;--x:#d53f8c;--o:#2b6cb0}
    *{box-sizing:border-box}
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans",Arial;display:flex;align-items:center;justify-content:center;min-height:100vh;margin:0;background:linear-gradient(180deg,#eef2ff, #f7fbff)}
    .wrap{width:360px;max-width:95%;background:var(--card);border-radius:12px;padding:18px;box-shadow:0 8px 24px rgba(40,40,80,0.08);text-align:center}
    h1{margin:0 0 8px;font-size:20px}
    p{margin:0 0 12px;color:#555}

    .board{display:grid;grid-template-columns:repeat(3,1fr);gap:8px;padding:8px;margin-bottom:12px}
    .cell{aspect-ratio:1/1;border-radius:8px;background:linear-gradient(180deg,#ffffff,#f3f6ff);display:flex;align-items:center;justify-content:center;font-size:40px;cursor:pointer;user-select:none;transition:transform .12s, box-shadow .12s}
    .cell:hover{transform:translateY(-3px);box-shadow:0 6px 16px rgba(60,72,142,0.06)}
    .cell.disabled{cursor:not-allowed;opacity:.9}

    .info{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px}
    .turn{font-weight:600}
    .controls{display:flex;gap:8px}
    button{border:0;padding:8px 12px;border-radius:8px;background:var(--accent);color:#fff;cursor:pointer}
    button.secondary{background:#e2e8f0;color:#111}
    .line{height:8px;border-radius:8px;margin-top:10px;background:linear-gradient(90deg,var(--x),var(--o));opacity:0.07}

    /* 勝利強調（簡單處理：被選中的 cell 會加上 effect） */
    .win{box-shadow:0 6px 18px rgba(0,0,0,0.08);transform:scale(1.03)}
    .msg{margin-top:10px;color:#111;font-weight:600}
    .hidden{display:none}

    @media (max-width:420px){.cell{font-size:32px}}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>圈圈叉叉（Tic‑Tac‑Toe）</h1>
    <p>兩人本機遊玩：玩家 X 與 O 輪流下，先連成一排者勝出。</p>

    <div class="info">
      <div class="turn">當前玩家：<span id="current">X</span></div>
      <div class="controls">
        <button id="restart">重新開始</button>
        <button id="resetScore" class="secondary">清除計分</button>
      </div>
    </div>

    <div class="board" id="board">
      <!-- 9 個格子 由 JS 產生 -->
    </div>

    <div class="line"></div>
    <div class="msg" id="message">輪到玩家 X</div>

    <div style="margin-top:10px;color:#444;font-size:14px">
      <span>計分 — X: <span id="scoreX">0</span></span>
      &nbsp;|&nbsp;
      <span>O: <span id="scoreO">0</span></span>
      &nbsp;|&nbsp;
      <span>平手: <span id="scoreT">0</span></span>
    </div>
  </div>

  <script>
    // ---------- Step 1: state 定義 ----------
    const boardEl = document.getElementById('board');
    const currentEl = document.getElementById('current');
    const messageEl = document.getElementById('message');
    const restartBtn = document.getElementById('restart');
    const resetScoreBtn = document.getElementById('resetScore');
    const scoreXEl = document.getElementById('scoreX');
    const scoreOEl = document.getElementById('scoreO');
    const scoreTEl = document.getElementById('scoreT');

    let board = Array(9).fill(''); // 空字串代表空格
    let currentPlayer = 'X';
    let playing = true;
    let scores = { X: 0, O: 0, T: 0 };

    // 勝利組合（index）：
    const wins = [
      [0,1,2],[3,4,5],[6,7,8], // 橫
      [0,3,6],[1,4,7],[2,5,8], // 直
      [0,4,8],[2,4,6] // 斜
    ];

    // ---------- Step 2: 建構 UI（九格） ----------
    function buildBoard(){
      boardEl.innerHTML = '';
      for(let i=0;i<9;i++){
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.dataset.index = i;
        cell.addEventListener('click', onCellClick);
        boardEl.appendChild(cell);
      }
    }

    // ---------- Step 3: click handler ----------
    function onCellClick(e){
      const idx = Number(e.currentTarget.dataset.index);
      if(!playing) return; // 遊戲結束禁止下子
      if(board[idx] !== '') return; // 已有棋子

      board[idx] = currentPlayer;
      e.currentTarget.textContent = currentPlayer;
      e.currentTarget.classList.add('disabled');

      // 檢查是否勝利或平手
      const winCombo = checkWin();
      if(winCombo){
        playing = false;
        highlightWin(winCombo);
        messageEl.textContent = `玩家 ${currentPlayer} 獲勝！`;
        scores[currentPlayer]++;
        updateScores();
        return;
      }

      if(board.every(cell => cell !== '')){
        // 平手
        playing = false;
        messageEl.textContent = '平手！';
        scores.T++;
        updateScores();
        return;
      }

      // 換玩家
      currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
      currentEl.textContent = currentPlayer;
      messageEl.textContent = `輪到玩家 ${currentPlayer}`;
    }

    // ---------- Step 4: 檢查勝利 ----------
    function checkWin(){
      for(const combo of wins){
        const [a,b,c] = combo;
        if(board[a] && board[a] === board[b] && board[a] === board[c]){
          return combo; // 回傳勝利的三格 index
        }
      }
      return null;
    }

    // ---------- Step 5: 高亮勝利格子 ----------
    function highlightWin(combo){
      combo.forEach(i => {
        const cell = boardEl.querySelector(`.cell[data-index='${i}']`);
        if(cell){
          cell.classList.add('win');
        }
      });
    }

    // ---------- Step 6: 重新開始/重置 ----------
    function resetBoard(){
      board = Array(9).fill('');
      currentPlayer = 'X';
      playing = true;
      currentEl.textContent = currentPlayer;
      messageEl.textContent = `輪到玩家 ${currentPlayer}`;
      // 清空格子文字與 class
      document.querySelectorAll('.cell').forEach(c => {
        c.textContent = '';
        c.classList.remove('disabled','win');
      });
    }

    function updateScores(){
      scoreXEl.textContent = scores.X;
      scoreOEl.textContent = scores.O;
      scoreTEl.textContent = scores.T;
    }

    restartBtn.addEventListener('click', resetBoard);
    resetScoreBtn.addEventListener('click', ()=>{
      scores = { X:0, O:0, T:0 };
      updateScores();
      resetBoard();
    });

    // ---------- 初始化 ----------
    buildBoard();
    updateScores();

    // ---------- 擴充練習（你可以做的改進） ----------
    // 1. 加入簡單 AI：當玩家是 O 時讓電腦下子（隨機或簡單策略）
    // 2. 加入動畫與聲音效果
    // 3. 記憶分數到 localStorage，關閉再開還能保留
    // 4. 線上對戰：用 WebSocket 或 Firebase Realtime Database

  </script>
</body>
</html>
